// Generated by CoffeeScript 1.8.0
(function() {
  angular.module('cmsApp').service('Github', function($http, $q) {
    var BRANCH, ENDPOINT, GithubToken, REPO, request;
    ENDPOINT = "https://api.github.com/";
    REPO = "biilmann/timespace.dk";
    BRANCH = "links";
    GithubToken = localStorage.getItem("gh_token");
    request = function(method, path, config, cb) {
      var headers;
      headers = {
        "Authorization": "token " + GithubToken
      };
      return $http({
        url: ENDPOINT + path,
        method: method.toUpperCase(),
        headers: angular.extend({}, headers, config.headers),
        params: config.params,
        data: config.data,
        transformResponse: config.transformResponse || $http.defaults.transformResponse
      }).then(function(response) {
        if (cb) {
          return cb(response.data, response.headers);
        } else {
          return response.data;
        }
      });
    };
    return {
      hasToken: function() {
        return !!GithubToken;
      },
      setToken: function(token) {
        GithubToken = token;
        return localStorage.setItem("gh_token", token);
      },
      removeToken: function() {
        GithubToken = null;
        return localStorage.removeItem("gh_token");
      },
      repo_branches: function(cb) {
        return request("get", "repos/" + REPO + "/branches", {}, cb);
      },
      repo_contents: function(cb) {
        return request("get", "repos/" + REPO + "/contents/", {}, cb);
      },
      repo_file_info: function(options, cb) {
        return request("get", "repos/" + REPO + "/contents/" + options.path, {
          params: {
            ref: BRANCH
          }
        }, cb);
      },
      repo_file: function(options, cb) {
        return request("get", "repos/" + REPO + "/contents/" + options.path, {
          headers: {
            "Accept": "application/vnd.github.VERSION.raw"
          },
          transformResponse: angular.identity,
          params: {
            ref: BRANCH
          }
        }, cb);
      },
      update_file: function(options, cb) {
        console.log("Updating file %o", options);
        return request("put", "repos/" + REPO + "/contents/" + options.path, {
          data: {
            message: options.message,
            content: Base64.encode(options.content),
            sha: options.sha,
            branch: BRANCH
          }
        }, cb);
      },
      repo_branch: function(cb) {
        return request("get", "repos/" + REPO + "/branches/" + BRANCH, {}, cb);
      },
      repo_tree: function(sha, cb) {
        if (sha) {
          return request("get", "repos/" + REPO + "/git/trees/" + sha, {}, cb);
        } else {
          return cb({
            tree: []
          });
        }
      },
      updateTree: function(sha, path, fileTree) {
        var defered;
        defered = $q.defer();
        this.repo_tree(sha, (function(_this) {
          return function(tree) {
            var data, fileOrDir, filename, obj, updates, _i, _len, _ref;
            updates = [];
            _ref = tree.tree;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              obj = _ref[_i];
              if (fileOrDir = fileTree[obj.path]) {
                fileOrDir.added = true;
                if (fileOrDir.file) {
                  updates.push({
                    path: obj.path,
                    mode: obj.mode,
                    type: obj.type,
                    sha: fileOrDir.sha
                  });
                } else {
                  updates.push(_this.updateTree(obj.sha, obj.path, fileOrDir));
                }
              }
            }
            for (filename in fileTree) {
              data = fileTree[filename];
              if (!data.added) {
                if (data.file) {
                  updates.push({
                    path: filename,
                    mode: "100644",
                    type: "blob",
                    sha: data.sha
                  });
                } else {
                  updates.push(_this.updateTree(null, filename, data));
                }
              }
            }
            return $q.all(updates).then(function(updates) {
              return request("post", "repos/" + REPO + "/git/trees", {
                data: {
                  base_tree: sha,
                  tree: updates
                }
              }, function(response) {
                defered.resolve({
                  path: path,
                  mode: "040000",
                  type: "tree",
                  sha: response.sha
                });
                return console.log("Updates: %o", updates);
              });
            });
          };
        })(this));
        return defered.promise;
      },
      uploadBlob: function(file) {
        var defered;
        defered = $q.defer();
        request("post", "repos/" + REPO + "/git/blobs", {
          data: {
            content: file.base64 ? file.base64() : Base64.encode(file.content),
            encoding: "base64"
          }
        }, function(response) {
          file.sha = response.sha;
          return defered.resolve(file);
        });
        return defered.promise;
      },
      update_files: function(options, cb) {
        var file, fileTree, filename, files, part, parts, subtree, _i, _len, _ref;
        fileTree = {};
        console.log("Got files: %o", options);
        files = [];
        _ref = options.files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          files.push(file.upload ? file : this.uploadBlob(file));
          parts = (function() {
            var _j, _len1, _ref1, _results;
            _ref1 = file.path.split("/");
            _results = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              part = _ref1[_j];
              if (part) {
                _results.push(part);
              }
            }
            return _results;
          })();
          filename = parts.pop();
          subtree = fileTree;
          while (part = parts.shift()) {
            subtree[part] || (subtree[part] = {});
            subtree = subtree[part];
          }
          subtree[filename] = file;
          file.file = true;
        }
        return $q.all(files).then((function(_this) {
          return function() {
            console.log("tree: %o", fileTree);
            return _this.repo_branch(function(branch) {
              return _this.updateTree(branch.commit.sha, '/', fileTree).then(function(changeTree) {
                return request("post", "repos/" + REPO + "/git/commits", {
                  data: {
                    message: options.message,
                    tree: changeTree.sha,
                    parents: [branch.commit.sha]
                  }
                }, function(response) {
                  return request("patch", "repos/" + REPO + "/git/refs/heads/" + BRANCH, {
                    data: {
                      sha: response.sha
                    }
                  }, function(ref) {
                    return cb(ref);
                  });
                });
              });
            });
          };
        })(this));
      }
    };
  });

}).call(this);
